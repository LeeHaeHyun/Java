package ex01;

import java.util.Scanner;

public class ArrayFour
{
	public static void main(String[] args)
	{
		/*
		 * 4. String 2차원 배열을 이용하여 자바 용어 맞추기 게임을 만들어라! 정답이면 정답입니다. 오답이면 틀렸습니다. 정답은 ~입니다
		 * 라고 출력되어야 한다.
		 */
		// 1. 문제와 정답이 담긴 2차원 배열 생성
		String[][] javas = { { "프로그램에서 사용되는 데이터 유형(data type)", "자료형" }, { "변수의 아무것도 안들어간 더미데이터(빈 데이터)", "null" },
				{ "힙 영역의 값을 호출하기 위해 객체의 메모리 위치의 어떤 것을 찾아야 할까?(ㅈㅅㄱ)", "주소값" }, { "데이터가 저장되는 메모리의 기억장소에 붙인 이름", "변수" },
				{ "메소드 안에서 선언되어 메소드 안에서만 사용되는 변수", "지역변수" }, { "데이터를 전달하면서 메소드를 호출할 때 전달 데이터를 저장할 변수", "매개변수" },
				{ "데이터 저장을 위한 메모리 공간을 확보해달라고 가상머신에게 부탁하는 행위", "변수선언" }, { "변수 선언 이후 처음으로 데이터를 저장하는 행위", "초기화" },
				{ "조건문이 true일때만 실행(?문)", "if문" }, { "변수값이 설정한 데이터가 같을때 실행(?문)", "switch문" },
				{ "true면 다음, false면 주로 한정된 반복문 탈출(?문)", "for문" }, { "조건식이 true면 실행, false면 주로 무한반복문 탈출(?문)", "while문" },
				{ "일단 실행구문 수행하고 조건식 true면 반복, false면 탈출(?-?문)", "do-while문" },
				{ "배열객체참조변수 안에 데이터를 저장하고 실행구문 반복(?-?문)", "향상된-for문" },
				{ "조건식이 false면 반복진행, true면 실행구문 계속 실행하지 않고 반복문 탈출", "break" }, { "강제로 다음 반복 구문으로 건너뜀", "continue" },
				{ "패시브! 클래스가 객체화가 되어야 속성변수가 메소드가 호출한 실행구문이 이루어짐", "생성자" }, { "행동! 실행구문을 대표하는 방법 이름(ㅔㅗㅡ)", "메소드" },
				{ "클래스를 실행하면 메모리 공간(Heap)으로 올라간다. 같은말로 인스턴스", "객체" }, { "메소드 실행 후에 아무런 값도 반환하지 않는다.", "void" },
				{ "메소드 실행을 중지하고 데이터를 호출한 곳으로 반환하라.", "return" }, { "클래스가 소유한 고유멤버(속성변수, 메소드, 생성자)를 지칭", "this" },
				{ "클래스의 특성 중 정보 은닉을 가장 잘 보여주는 메소드(영어/영어)", "getter/setter" },
				{ "같은 이름의 생성자를 2개 이상 정의하는 것(한글로)", "오버로딩" }, 
				};
		// 2. 사용자로부터 입력값을 받는다.
		Scanner scan = new Scanner(System.in);

		// 3. 만든 배열의 전체를 탐색한다.
		for (int i = 0; i < javas.length; i++)
		{
			System.out.printf("문제%d] %s 는 무엇일까요? ", i + 1, javas[i][0]);

			// 4. 사용자로부터 입력값을 저장한다.
			String good = scan.nextLine();

			// 5. 정답인지 틀렸는지 판별한다
			if (good.equals(javas[i][1]))
			{
				System.out.printf("대단한데요~? 정답입니다!%n%n");
			} 
			else 
			{
				System.out.printf("아쉽게도 틀렸어요! 정답은 [%s]입니다.%n%n", javas[i][1]);
				
			}
			
		}
		scan.close();
	}
}
